using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Algorithm
{
    /// <summary>
    /// 链表运算
    /// 两个链表结构来生成新的链表结构
    /// </summary>
    public class LinkList
    {
        //Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
        //Output: 7 -> 0 -> 8
        //Explanation: 342 + 465 = 807.
        //Input: (1->8) + (0)
        //Explanation: 81 + 0 = 81.

        /// <summary>
        /// 需要做一个计算方法，不用数值转换，数组遍历累加，考虑进位
        /// </summary>
        /// <param name="l1"></param>
        /// <param name="l2"></param>
        /// <returns></returns>
        public LinkListData AddLinkList(LinkListData l1, LinkListData l2)
        {
            var tempdata = l1;
            List<int> list1 = new List<int>();
            while (tempdata != null)
            {                
                list1.Add(tempdata.val);
                tempdata = tempdata.next;
            }
            List<int> list2 = new List<int>();
            tempdata = l2;
            while (tempdata != null)
            {
                list2.Add(tempdata.val);
                tempdata = tempdata.next;
            }

            int count1 = list1.Count;
            int count2 = list2.Count;
            for (int idx = 0; idx < Math.Abs(count1 - count2); idx++)
            {
                if (count1 > count2)
                    list2.Add(0);
                else if (count1 < count2)
                    list1.Add(0);
            }

            int[] arr = TwoArrayAdd(list1.ToArray(),list2.ToArray());
            foreach (var item in arr)
            {
                AddToLinkedList(item);
            }
            return First;
        }

        public LinkListData First { get; set; }
        public LinkListData Last { get; set; }
        /// <summary>
        /// Method to Add items into the Linked List
        /// </summary>
        /// <param name="_value"></param>
        public void AddToLinkedList(object _value)
        {
            LinkListData node = new LinkListData(Convert.ToInt32(_value));
            if (First == null)
            {
                First = node;
                Last = node;
            }
            else
            {
                Last.next = node;
                Last = node;
            }
        }

        /// <summary>
        /// Method to display all items. We can further implement the IEnumerable interface
        /// to Yield IEnumerator Interface.
        /// </summary>
        public void DisplayAllItems()
        {
            LinkListData current = First;
            while (current != null)
            {
                Console.WriteLine(current.val);
                current = current.next;
            }
        }

        /// <summary>
        /// 两个数组相加
        /// 需要考虑进位
        /// </summary>
        /// <param name="firstArr"></param>
        /// <param name="lastArr"></param>
        /// <returns></returns>
        private int[] TwoArrayAdd(int[] firstArr,int[] lastArr)
        {
            int[] maxArr = firstArr.Length >= lastArr.Length ? firstArr : lastArr;
            int[] minArr = firstArr.Length < lastArr.Length ? firstArr : lastArr;
            List<int> result = new List<int>();
            int carry = 0;
            if (firstArr.Sum() == 0 || lastArr.Sum() == 0)
            {
                return firstArr.Sum() == 0?lastArr:firstArr;
            }
            for (int idx = 0; idx < maxArr.Length; idx++)
            {
                var res = maxArr[maxArr.Length - 1 - idx] + (minArr.Length - 1 - idx>=0?minArr[minArr.Length - 1 - idx]:0);
                result.Add((res+carry) % 10);
                carry = (res+carry) / 10;
            }
            if (carry == 1)
            {
                result.Add(1);
            }
            return result.ToArray();
        }
    }

    /// <summary>
    /// 定义链表类
    /// </summary>
    public class LinkListData
    {
        public int val;

        public LinkListData next;
        
        public LinkListData(int x) { val = x; }
    }
}
